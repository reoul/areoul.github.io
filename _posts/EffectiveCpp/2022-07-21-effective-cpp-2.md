---
title: "Effective C++ 챕터 2 정리" 

categories:
  - Effective C++
tags:
  - [Effective C++, Book Summary]
# 태그는 무조건 2개 이상(1개면 글이 안보임)

toc: true
toc_sticky: true
#목차 생성 여부

published: true
#글 공개 여부(false해도 주소로 접근 가능)

date:       2022-07-21T18:34:00+09:00
lastmod:    2022-07-21T18:34:00+09:00
---

이 글은 스콧 마이어스님의 책 Effective C++을 읽고 정리한 글입니다
{: .notice--warning}

<br>

# Chapter 2 생성자, 소멸자 및 대입 연산자

## 📌 항목 5: C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉가을 세우자

- 복사 생성자, 복사 대입 연산자, 소멸자는 직접 선언해 넣지 않으면 컴파일러가 저절로 선언해 준다
- 생성자조차도 선언되어 있지 않으면 역시 컴파일러가 대신 기본 생성자를 선언해 놓는다
- 소멸자는 이 클래스가 상속한 기본 클래스의 소멸자가 가상 소멸자로 되어 있지 않으면 역시 **비가상 소멸자로 만들어 진다**
- 참조자나 상수같은 경우 대입이 안되기 때문에 직접 복사 대입 연산자를 정의해주어야 한다
- 복사 대입 연산자를 `private`로 선언한 기본 클래스로부터 파생된 클래스의 경우, 이 클래스는 암시적 복사 대입 연산자를 가질 수 없습니다
- 컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있습니다

<br>

## 📌 항목 6: 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자

- 복사 생성자와 복사 대입 연산자를 `private` 멤버로 선언하면 외부로부터의 호출을 차단할 수 있습니다
- `private` 멤버 함수는 그 클래스의 멤버 함수 및 프렌드 함수가 호출할 수 있기 때문에 '**정의(define)**'를 하지 않으면 된다
  - 정의되지 않는 함수를 누군가가 실수로 호출하려 했다면 분명히 링크 시점에 에러를 보게 된다
- 복사 생성자와 복사 대입 연산자를 `private`로 선언하되, 이것을 별도의 기본 클래스에 넣고 이것으로부터 파생클래스를 만들어 깔끔하게 할 수도 있다

```cpp
class Uncopyable {
protected:
    Uncopyable() {}                                 // 생성과 소멸을
    ~Uncopyable() {}                                // 허용합니다
private:
    Uncopyable(const Uncopyable&);                  // 하지만 복사 방지
    Uncopyable& operators=(const Uncopyable&);
};

class HomeForSale : private Uncopyable {            // 복사 생성자, 복사 대입 연산자도 선언되지 않습니다
    ...
};
```

<br>

## 📌 항목 7: 다형성을 가진 기본 클래스에는 소멸자를 반드시 가상 소멸자로 선언하자

- C++ 규정에 의하면, 기본 클래스 포인터를 통해 파생 클래스 객체가 삭제될 때 그 기본 클래스에 비가상 소멸자가 들어 이씅면 프로그램 동작은 **미정의 사항**이라고 되어 있습니다
  - 대개 그 객체의 파생 클래스 부분이 소멸되지 않게 된다
- 결국 **메모리 누수**로 이어질 수 있다
- 기본 클래스에 가상 소멸자를 정의하면 해당 문제는 해결된다
- 가상 함수를 하나라도 가진 클래스는 가상 소멸자를 가져야 하는 게 대부분 맞습니다
- vptr(가상 함수 테이블 포인터 virtual table pointer)은 가상 함수의 주소, 즉 포인터들의 배열을 가리키고 있으며 가상 함수 테이블 포인터의 배열은 vtbl(가상 함수 테이블 virtual table)이라고 불린다
- 가상 함수를 하나라도 갖고 있는 클래스는 반드시 그와 관련된 vtbl을 갖고 있습니다
- 실제 함수는 그 객체의 vptr이 가리키는 vtbl에 따라 결정됩니다
- Point 클래스에 **가상 함수가 들어가게 되면 Point 타입 객체의 크기가 커진다**
- 어느 경우를 막론하고 소멸자를 전부 `virtual`로 선언하는 일은 `virtual`로 절대 선언하지 않는 것만큼이나 편찮은 마인드입니다
- 가상 소멸자를 선언하는 것은 그 클래스에 **가상 함수가 하나라도 있는 경우**에만 한정하세요
- 추상 클래스로 만들고 싶은 클래스에 순수 가상 소멸자를 선언한다
- 소멸자가 동작하는 순서는 상속 계통 구조에서 가장 말단에 있는 파생 클래스의 소멸자가 호출되는 것을 시작으로, 기본 클래스 쪽으로 거쳐 올라가면서 각 기본 클래스의 소멸자가 하나씩 호출됩니다
  - 컴파일러는 ~AWOV의 호출 코드를 만들기 위해 파생 클래스의 소멸자를 사용할 것이므로, 잊지 말고 이 함수의 본문을 준비해 두어야 한다
  - 만약 이 부분을 잊으면 링커 에러를 보게 된다
  - 그래서 순수 가상 소멸자의 정의를 두지 않으면 안된다

<br>

## 📌 항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

<br>

***
<br>

    💻 열심히 공부해서 작성 중이니 오류나 틀린 부분이 있을 경우 
      언제든지 댓글 혹은 메일로 알려주시면 감사하겠습니다! 😸

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}