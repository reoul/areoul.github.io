---
title: "[Effective C++] 챕터 3 : 자원 관리" 

categories:
  - Effective-Cpp
tags:
  - [Cpp, Book Summary]


toc: true
toc_sticky: true
#목차 생성 여부

published: false
#글 공개 여부

date:       2022-11-07T02:53:00+09:00
lastmod:    2022-11-07T02:53:00+09:00
---

이 글은 스콧 마이어스님의 책 Effective C++의 챕터 3을 읽고 정리한 글입니다
{: .notice--warning}

<br>

## 📌 항목 13: 자원 관리에는 객체가 그만

- `new`를 하고 `delete`을 할 때 그 사이에서 `return`이나 `continue`와 같이 갑자기 루프를 빠져나왔을 때는 `delete`을 하지 못하여 **메모리 누수가 생긴다**
- 자원이 항상 해제되도록 만들 방법은 자원을 객체에 넣고 그 자원 해제를 소멸자가 맡도록 하며, 그 소멸자는 실행 제어가 함수를 떠날 때 호출되도록 만드는 것입니다
- 자원을 객체에 넣음으로써, **C++가 자동으로 호출해 주는 소멸자에 의해 해당 자원을 저절로 해제할 수 있습니다**
- **스마트 포인터**는 가리키고 있는 대상에 대해 소멸자가 자동으로 delete를 불러주도록 설계되어 있습니다

<br>

## 📌 항목 14: 자원 관리 클래스의 복사 동장에 대해 진지하게 고찰하자

- Mutex 잠금을 관리하는 클래스를 하나 만들고 싶습니다
- 이런 용도의 클래스는 기본적으로 RAII 법칙을 따라 구성합니다
- 그런데 Lock 객체가 복사된다면 어떻게 해야 할까요?
- **복사를 금지합니다**
  - 실제로, RAII 객체가 복사되도록 놔두는 것 자제가 말이 안 되는 경우가 꽤 많습니다
  - 어떤 스레드 동기화 객체에 대한 '사본'이라는 게 실제로 거의 의미가 없으니까요
  - 복사하면 안 되는 RAII 클래스에 대해서는 반드시 복사가 되지 않도록 막아야 합니다
- 관리하고 있는 자원에 대해 **참조 카운팅을 수행**합니다
  - 자원을 사용하고 있는 마지막 객체가 소멸될 때까지 그 자원을 저 세상으로 안 보내는 게 바람직할 경우도 종종 있습니다
  - 이럴 경우에는, 해당 자원을 참조하는 객체의 개수에 대한 카운트를 증가시키는 식으로 RAII 객체의 복사 동작을 만들어야 합니다
- 관리하고 있는 자원을 **진짜로 복사**합니다
  - 때에 따라서는 자원을 원하는 대로 복사할 수도 있습니다
  - 이때는 '자원을 다 썼을 때 각각의 사본을 확실히 해제하는 것'이 자원 관리 클래스가 필요한 유일한 명분이 되는 것이죠
  - 자원 관리 객체를 복사하면 그 객체가 둘러싸고 있는 자원까지 복사되어야 합니다
- 관리하고 있는 **자원의 소유권**을 옮깁니다
  - 그리 흔한 경우는 아니지만, 어떤 특정한 자원에 대해 그 자원을 실제로 참조하는 RAII 객체는 딱 하나만 존재하도록 만들고 싶어서, 그 RAII 객체가 복사될 때 그 자원의 소유권을 사본 쪽으로 아예 옮겨야 할 경우도 살다 보면 생깁니다
- 객체 복사 함수는 컴파일러에 의해 생성될 여지가 있기 때문에, 컴파일러가 생성한 버전의 동작이 여러분이 원한 바와 맞지 않으면, 여러분이 **객체 복사 함수를 직접 만들 수밖에 없습니다**

<br>

## 📌 항목 15: 자원 관리 클래스에서 관리되는 자원을 외부에서 접근할 수 있도록 하자

- 이미 현장에서 열심히 쓰이고 있는 수많은 API들이 자원을 직접 참조하도록 만들어져 있다
- RAII 클래스의 객체를 그 객체가 감싸고 있는 실제 자원으로 변환할 방법이 필요하다
- 명시적 변환과 암시적 변환이 있다
- RAII 클래스를 실제 자원으로 바꾸는 방법으로써 명시적 변환을 제공할 것인지 아니면 암시적 변환을 허용할 것인지에 대한 결정은 그 RAII 클래스만의 특정한 용도와 사용 환경에 따라 달라집니다
- **RAII 클래스는 애초부터 데이터 은닉이 목적이 아닙니다**
- **원하는 동작(자원 해제)이 실수 없이 이루어지도록** 하면 OK인 걸요
- 굳이 원한다면 '자원 해제'라는 기본 기능 위에 캡슐화 기능을 얹을 수는 있겠지만, 꼭 필요한 것은 아닙니다

<br>

## 📌 항목 16: new 및 delete를 사용할 때는 형태를 반드시 맞추자

- `delete` 과 `delete[]` 은 분명한 차이가 있다
- 배열의 경우 `delete[]`을 하지 않는 경우 **나머지 요소들의 소멸자를 호출하지 않는다**
- `delete` 뒤에 `[]`을 붙여줌으로써 '포인터가 배열을 가리키고 있구나'라고 가정하게 됩니다

<br>

## 📌 항목 17: new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자

- 컴파일러는 함수 호출 코드를 만들기 전에 우선 이 함수의 매개변수로 넘겨지는 인자를 평가하는 순서를 밟습니다
- 그런데, 여기서 각각의 연산이 실행되는 순서는 컴파일러 제작사마다 다르다는게 문제입니다
- C++ 컴파일러의 경우엔 이들의 순서를 정하는 데 있어서 상당한 자유도를 갖고 있다
- 그래서 연산을 실행하는 경우에 예외가 발생했다면 할당된 메모리가 누출될 수 있다
- 함수 호출 중에 자원이 누출될 가능성이 있는 이유는, 자원이 생성되는 시점과 그 자원이 자원 관리 객체로 넘어가는 시점 사이에 예외가 끼어들 수 있기 때문이다
- 스마트 포인터에 저장하는 코드를 별도의 문장 하나로 만들고, 그 스마트 포인터를 다시 넘기는 것으로 하면 문제가 생기지 않는다
- 한 문장 안에 있느 연산들보다 문장과 문장 사이에 있는 연산들이 컴파일러의 재조정을 받을 여지가 적기 때문에 자원 누출 가능성이 없습니다

```cpp
std::tr1::shared_ptr<Widget> pw(new Widget);

processWidget(pw, priority());
```

- new로 생성한 객체를 스마트 포인터로 넣는 코드는 별도의 한 문장으로 만듭시다
- 이것이 안 되어 있으면, 예외가 발생될 때 디버깅하기 힘든 자원 누출이 초대될 수 있습니다

<br>

***
<br>

    💻 열심히 공부해서 작성 중이니 오류나 틀린 부분이 있을 경우 
      언제든지 댓글 혹은 메일로 알려주시면 감사하겠습니다! 😸

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}