---
title: "Effective C++ 챕터 1 정리" 

categories:
  - Effective C++
tags:
  - [Effective C++, Book Summary]
# 태그는 무조건 2개 이상(1개면 글이 안보임)

toc: true
toc_sticky: true
#목차 생성 여부

published: true
#글 공개 여부(false해도 주소로 접근 가능)

date: 2022-03-30
last_modified_at: 2022-04-01
---

이 글은 스콧 마이어스님의 책 Effective C++을 읽고 정리한 글입니다
{: .notice--warning}

<br>

# Chapter 1  C++에 왔으면 C++의 법을 따릅시다

## 📌 항목 1: C++를 언어들의 연합체로 바라보는 안목은 필수

<br>

## 📌 항목 2: #define을 쓰려거든 const, enum, inline을 떠올리자

- 매크로 대신 상수를 사용해라
- 상수 포인터를 정의 할 땐 포인터는 꼭 `const` 로 선언해 주어야 하고, <u>포인터가 가리키는 대상</u>까지 `const` 로 선언하는 것이 좋다
```cpp
const char * const authorName = "Scott Meyers"
```
- 클래스 상수의 초기값은 해당 상수가 <u>선언된 시점</u>에 바로 주어진다
- 정적 클래스 상수의 선언은 헤더 파일에 두고 정의는 구현 파일에 둡니다
- 선언한 정수 상수를 가지고 다른 사람이 주소를 얻는다든지 참조자를 쓴다든지 하는 것이 씷다면 **나열자 둔갑술**이 좋은 방법이 된다
- `enum` 은 `#define` 처럼 어떤 형태의 <u>쓸데없는 메모리 할당</u>을 절대 저지르지 않는다
- 나열자 둔갑술은 템플릿 메타프로그래밍의 핵심 기법이다
- 기존 매크로의 효율을 그대로 유지함은 물론 정규 함수의 모든 동작방식 및 타입 안전성 얻을 수 있는 방법은 **인라인 함수에 대한 템플릿**을 준비하는 것이다

<br>

## 📌 항목 3: 낌새만 보이면 const를 들이대 보자!

- 타입 앞에 const를 붙이거나 타입의 뒤쪽이자 *표의 앞에 const를 붙이는 것은 차이가 없다
```cpp
void f1(cosnt Widget *pw);    // 둘다 상수 Widget 객체에 대한
void f2(Widget const *pw);    // 포인터를 매개변수로 취합니다
```
- STL 반복자는 포인터를 본뜬 것이므로 기본적인 동작 원리는 T* 포인터랑 흡사합니다
- 만약 변경이 불가능한 객체를 가리키는 반복자가 필요하다면 const_iterator를 사용하면 된다
- operator의 반환 값을 상수로 되게 하면 아래와 같은 실수를 방지 할 수 있다
```cpp
if (a * b = c) ...
```

<br>

## 📌 항목 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자

<br>

***
<br>

    💻 열심히 공부해서 작성 중이니 오류나 틀린 부분이 있을 경우 
      언제든지 댓글 혹은 메일로 알려주시면 감사하겠습니다! 😸

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}